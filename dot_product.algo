PROCEDURE dot_product ( VAR ps: INTEGER)
VAR
    v1 : ARRAY_OF INTEGER[];
    v2 : ARRAY_OF INTEGER[];
    i : INTEGER;
BEGIN
    FOR i FROM 0 TO v1.length-1 STEP step  DO
        Write(v1[i]);
    END_FOR
    FOR i FROM 0 TO v2.length-1 STEP step  DO
        Write(v2[i])
    END_FOR
    Write(v1[i].v2[i])
    Read(ps)
END

PROCEDURE dot_product ( ps: INTEGER)
VAR
    v1 : ARRAY_OF INTEGER[];
    v2 : ARRAY_OF INTEGER[];
    i, R : INTEGER;
BEGIN
    FOR i FROM 0 TO v1.length-1 STEP step  DO
        Write(v1[i]);
    END_FOR
    FOR i FROM 0 TO v2.length-1 STEP step  DO
        Write(v2[i])
    END_FOR
    Write(v1[i].v2[i])
    Read(ps)
END

FUNCTION R : return_type INTEGER[2]
VAR
    v1 : ARRAY_OF INTEGER[];
    v2 : ARRAY_OF INTEGER[];
    i : INTEGER;
BEGIN
    FOR i FROM 0 TO v1.length-1 STEP step  DO
        Write(v1[i]);
    END_FOR
    FOR i FROM 0 TO v2.length-1 STEP step  DO
        Write(v2[i])
    END_FOR
    R := {v1[i], v2[i]};
    RETURN value ;
END

ALGORITHM dot_product
VAR
    n, i, p,: INTEGER;
BEGIN
    FOR i FROM 0 TO n.length-1 STEP step  DO
        Write(n[i])
            IF (n[i] = R()) THEN
                p := dot_product(n)*0;
            END_IF
    END_FOR
        Write(p)//p is the dot_product
END